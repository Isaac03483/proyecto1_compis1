package com.mio.cliente.boxworld.compiler.parser;

import com.mio.cliente.boxworld.compiler.lexer.MovesLexer;
import com.mio.cliente.boxworld.compiler.parser.MovesParserSym;
import com.mio.cliente.boxworld.compiler.Token;
import com.mio.cliente.boxworld.models.Move;
import java.util.ArrayList;


/*
 java -jar java-cup-11b.jar /home/mio/Escritorio/2023/proyecto-1-compis1/Boxworld/app/src/main/cup/moves.cup
*/

class MovesParser;

parser code{:

    public MovesParser(MovesLexer lexer){
        super(lexer);
    }
:}


/*
	main -> main movProd
	main -> movProd

	movProd -> push dirProd
	movProd -> dirProd

	dirProd -> direccion ( numero ) ;

	direccion -> right
	direccion -> left
	direccion -> up
	direccion -> down

	numero -> a
	numero -> ENTERO

	a -> a + b
	a -> a - b
	a -> b

	b -> b * c
	b -> b / c
	b -> - c
	b -> c

	c -> ( d )
	c -> d

	d -> funcion ( a )
	d -> a
	d -> ENTERO

	funcion -> floor
	funcion -> ceil
*/

terminal Token SUMA, RESTA, MULTIPLICACION, DIVISION, PARENTESIS_A, PARENTESIS_C, PUNTO_COMA, ENTERO, DECIMAL;
terminal Token RIGHT, LEFT, UP, DOWN, PUSH, FLOOR, CEIL;
non terminal ArrayList<Move> main;
non terminal Move movProd, dirProd;
non terminal Double a, b, c, d;
non terminal Integer direccion, funcion,numero;


start with main;

main ::=
    main:moves movProd:m                        {:moves.add(m);
                                                RESULT = moves;:}
    | movProd:m                                 {:RESULT = new ArrayList<Move>();
                                                RESULT.add(m);:}
    ;

movProd ::=
    PUSH dirProd:m                              {:m.setPush(true);
                                                  RESULT = m;:}
    | dirProd:m                                 {:RESULT = m;:}
    ;

dirProd ::=
    direccion:d PARENTESIS_A numero:n1 PARENTESIS_C PUNTO_COMA        {:RESULT = new Move(false,d,n1);:}
    ;

direccion ::=
    RIGHT:d                                     {:RESULT = Integer.valueOf(d.getType());:}
    | LEFT:d                                    {:RESULT = Integer.valueOf(d.getType());:}
    | UP:d                                      {:RESULT = Integer.valueOf(d.getType());:}
    | DOWN:d                                    {:RESULT = Integer.valueOf(d.getType());:}
    ;

numero ::=
    a:n1                                        {:RESULT = n1.intValue();:}
    ;

a ::=
    a:n1 SUMA b:n2                              {:RESULT = n1 + n2;:}
    | a:n1 RESTA b:n2                           {:RESULT = n1 - n2;:}
    | b:n1                                      {:RESULT = n1;:}
    ;

b ::=
    b:n1 MULTIPLICACION c:n2                    {:RESULT = n1 * n2;:}
    | b:n1 DIVISION c:n2                        {:RESULT = n1 / n2;:}
    | RESTA c:n1                                {:RESULT = -1 * n1;:}
    | c:n1                                      {:RESULT = n1;:}
    ;

c ::=
    PARENTESIS_A a:n1 PARENTESIS_C              {:RESULT = n1;:}
    | d:n1                                      {:RESULT = n1;:}
    ;

d ::=
    funcion:f PARENTESIS_A a:n1 PARENTESIS_C      {:RESULT = f == MovesParserSym.FLOOR ? Math.floor(n1): Math.ceil(n1);:}
    | ENTERO:e                                  {:RESULT = Double.valueOf(e.getValue());:}
    | DECIMAL:d                                 {:RESULT = Double.valueOf(d.getValue());:}
    ;

funcion ::=
    FLOOR:f                                     {:RESULT = f.getType();:}
    | CEIL:c                                    {:RESULT = c.getType();:}
    ;



